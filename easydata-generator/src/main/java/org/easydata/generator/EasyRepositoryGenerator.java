package org.easydata.generator;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.csv.CSVRecord;
import org.easydata.access.EasyCSVRepository;
import org.easydata.access.EasyRepository;
import org.easydata.model.EasyClass;
import org.easydata.model.EasyField;
import org.easydata.model.EasyModel;
import org.easydata.model.EasyRelation;
import org.easydata.model.EasyType;

import com.sun.codemodel.JBlock;
import com.sun.codemodel.JClass;
import com.sun.codemodel.JClassAlreadyExistsException;
import com.sun.codemodel.JCodeModel;
import com.sun.codemodel.JDefinedClass;
import com.sun.codemodel.JExpr;
import com.sun.codemodel.JExpression;
import com.sun.codemodel.JFieldVar;
import com.sun.codemodel.JMethod;
import com.sun.codemodel.JMod;
import com.sun.codemodel.JPackage;
import com.sun.codemodel.JType;
import com.sun.codemodel.JVar;
import com.sun.codemodel.JWhileLoop;

import it.unimi.dsi.fastutil.objects.Object2ObjectMap;
import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;

public class EasyRepositoryGenerator extends EasyCodeGenerator {

	private static final String _MODEL_PACKAGE_NAME = "your.domain.data";
	private static final String _REPOSITORIES_CLASS = "Repositories";

	private static final Comparator<EasyField> _FIELD_INDEX_COMP = new Comparator<EasyField>() {
		public int compare(EasyField one, EasyField two) {
			return one.index - two.index;
		}
	};

	private JCodeModel _cm = null;
	private EasyModel _em = null;

	@Override
	public void generateCode(EasyModel model, JCodeModel codeModel) {

		this._cm = codeModel;
		this._em = model;

		JPackage pkg = codeModel._package(_MODEL_PACKAGE_NAME);

		try {

			// generate Repositories class
			addRepositoriesClass();

			// define individual repository classes
			for (EasyClass clazz : model.classes) {
				addRepositoryClass(clazz, pkg);
			}

			// actually add methods to the individual repository classes
			for (EasyClass clazz : model.classes) {
				enhanceRepositoryClasses(clazz, pkg);
			}

			// after all repository classes have been added, modify the Repositories class again
			addRepositoriesInitMethod();

		} catch (JClassAlreadyExistsException jcae) {}

	}

	/**
	 * Creates a repository class for every class in the model.
	 * 
	 * @param clazz
	 * @param pkg
	 * @throws JClassAlreadyExistsException
	 */
	private void addRepositoryClass(EasyClass clazz, JPackage pkg) 
			throws JClassAlreadyExistsException {

		String name = getPlural(clazz.targetClassName);

		JClass superClass = this._cm.ref(EasyCSVRepository.class)
				.narrow(this._cm.ref(clazz.targetClassName));

		JDefinedClass jc = pkg._class(name);
		jc._extends(superClass);
		jc.javadoc().add("This class has been generated by the EasyData library.\n");
		jc.javadoc().add("DO NOT MODIFY this class manually.");

		// add main repository
		JFieldVar jField = addMainRepository(clazz, jc, jc.name());

		for (EasyRelation relation : clazz.getManyToOneRelations()) {
			// create indices for other objects which have a one to many to this one
			createReferenceIndex(clazz, relation, jc);
			// creates a getter for the parent object
			addGetParentMethod(clazz, relation, jc);
		}

		// getById method
		addGetByIdMethod(clazz, jc, jField);

	}

	private void addGetParentMethod(EasyClass clazz, EasyRelation relation, JDefinedClass jc) {

		System.out.println(clazz.targetClassName + " has relation to " + relation.getTo());

		String repoName = getPlural(clazz.targetClassName);
		JDefinedClass repo = this._cm._package(_MODEL_PACKAGE_NAME)._getClass(repoName);
		JDefinedClass repos = this._cm._package(_MODEL_PACKAGE_NAME)._getClass(_REPOSITORIES_CLASS);

		JClass returnType = this._cm.ref(relation.getTo());
		JClass repoType = this._cm.ref(getPlural(relation.getTo()));

		String name = "get" + relation.getTo();
		JMethod getParent = repo.method(JMod.PUBLIC, returnType, name);
		JVar param = getParent.param(this._cm.ref(clazz.targetClassName), clazz.targetClassName.toLowerCase());

		getParent.body()._return(
				repos.staticInvoke("get").arg(JExpr.dotclass(repoType))
				.invoke("getById").arg(param.invoke("get" + relation.getRefName())));

	}

	private void enhanceRepositoryClasses(EasyClass clazz, JPackage pkg) throws JClassAlreadyExistsException {

		JDefinedClass repositoryClass = getRepository(pkg, clazz);

		// create method to get objects from other repositories
		// which the class managed by this repo is managing
		for (EasyRelation relation : clazz.getOneToManyRelations()) {
			addGetByParentMethod(clazz, relation, repositoryClass);
		}

		// createFrom method
		addCreateFromMethod(clazz, repositoryClass);

		// add method
		addAddMethod(clazz, repositoryClass);

		// getInputFileName method
		addGetInputFileNameMethod(clazz, repositoryClass);

		// size method
		addSizeMethod(clazz, repositoryClass);

		// populateReferenceIndices method
		addPopulateReferenceIndicesMethod(clazz, repositoryClass);

	}

	private void addGetByParentMethod(EasyClass clazz, EasyRelation relation, JDefinedClass jc) {

		String repoName = relation.getTo() + getPluralSuffix(relation.getTo());
		JDefinedClass repo = this._cm._package(_MODEL_PACKAGE_NAME)._getClass(repoName);

		JType returnType = this._cm.ref(java.util.Set.class).narrow(this._cm.ref(relation.getTo()));

		String name = "get" + repoName + "By" + clazz.targetClassName + "Id";
		JMethod getByParentID = repo.method(JMod.PUBLIC, returnType, name);
		JVar parentId = getByParentID.param(String.class, clazz.targetClassName + "Id");

		// get index
		JClass keysType = this._cm.ref(java.util.Set.class).narrow(String.class);
		JVar keys = getByParentID.body().decl(keysType, "keys");
		String fieldName = repoName + "By" + clazz.targetClassName;
		JFieldVar indexVar = repo.fields().get(fieldName);
		keys.init(indexVar.invoke("get").arg(parentId));

		// result
		JClass resultType = this._cm.ref(java.util.Set.class).narrow(this._cm.ref(relation.getTo()));
		JClass resultTypeImpl = this._cm.ref(java.util.HashSet.class).narrow(this._cm.ref(relation.getTo()));
		JVar result = getByParentID.body().decl(resultType, repoName.toLowerCase());
		result.init(JExpr._new(resultTypeImpl));

		// populate
		JClass iterType = this._cm.ref(java.util.Iterator.class).narrow(String.class);

		JBlock ifBody =  getByParentID.body()
				._if(keys.eq(JExpr._null()).not().cand(keys.invoke("size").gt(JExpr.lit(0))))._then();

		JVar iter = ifBody.decl(iterType, "keyIter", keys.invoke("iterator"));
		ifBody._while(iter.invoke("hasNext")).body()
		.add(result.invoke("add").arg(
				JExpr._this().invoke("getById").arg(iter.invoke("next"))));

		getByParentID.body()._return(result);

	}

	private JFieldVar addMainRepository(EasyClass clazz, JDefinedClass jc, String name) {

		// map holding the single items
		JFieldVar jField = jc.field(JMod.PRIVATE, JCodeModelUtil.getObject2ObjectMapType(this._cm), name);
		jField.init(JExpr._new(JCodeModelUtil.getObject2ObjectMapImplType(this._cm)));

		return jField;

	}

	private void createReferenceIndex(EasyClass clazz, EasyRelation relation, JDefinedClass jc) {

		String name = getPlural(clazz.targetClassName);
		JFieldVar jField = jc.field(JMod.PRIVATE, JCodeModelUtil.getObject2ObjectMapType(this._cm), name + "By" + relation.getTo());
		jField.init(JExpr._new(JCodeModelUtil.getObject2ObjectMapImplType(this._cm)));

	} 

	private void addPopulateReferenceIndicesMethod(EasyClass clazz, JDefinedClass jc) {

		// create method definition
		String plural = getPlural(clazz.targetClassName);
		JDefinedClass repo = this._cm._package(_MODEL_PACKAGE_NAME)._getClass(plural);
		JFieldVar mainIndexVar = repo.fields().get(plural);

		JMethod populateReferenceIndices = jc.method(JMod.PROTECTED, this._cm.VOID, "populateReferenceIndices");

		// only populate the block if the class has Many-To-One relations
		if (!clazz.getManyToOneRelations().isEmpty()) {

			JClass iterType = this._cm.ref(java.util.Iterator.class).narrow(this._cm.ref(clazz.targetClassName));
			JVar iter = populateReferenceIndices.body().decl(iterType, "valuesIter", mainIndexVar.invoke("values").invoke("iterator"));

			JBlock whileBlock = populateReferenceIndices.body()._while(iter.invoke("hasNext")).body();

			JVar current = whileBlock.decl(this._cm.ref(clazz.targetClassName), clazz.targetClassName.toLowerCase(), iter.invoke("next"));

			for (EasyRelation relation : clazz.getManyToOneRelations()) {
				populateReferenceIndex(clazz, relation, jc, populateReferenceIndices, current, whileBlock);
			}

		}

	}

	private void populateReferenceIndex(EasyClass clazz, EasyRelation relation, 
			JDefinedClass jc, JMethod parentMethod, JVar current, JBlock whileBlock) {

		String plural = getPlural(clazz.targetClassName);
		String name =  plural + "By" + relation.getTo();
		whileBlock.directStatement("// populate " + name);

		JDefinedClass repo = this._cm._package(_MODEL_PACKAGE_NAME)._getClass(plural);

		JFieldVar indexVar = repo.fields().get(name);

		String fieldName = String.valueOf(name.charAt(0)).toLowerCase() + name.substring(1, name.length());

		JType setType = JCodeModelUtil.getStringHashSetType(this._cm); 

		JVar set = whileBlock.decl(
				setType, 
				fieldName, 
				indexVar.invoke("get").arg(current.invoke("get" + relation.getRefName())));

		JBlock ifBody = whileBlock._if(set.eq(JExpr._null()))._then();
		ifBody.assign(set, JExpr._new(setType));
		ifBody.invoke(indexVar, "put").arg(current.invoke("get" + relation.getRefName())).arg(set);

		whileBlock.invoke(set, "add").arg(current.invoke("getKeyValue"));

	}

	/**
	 * Creates the "createFrom" interface method.
	 * 
	 * @param clazz
	 * @param jc
	 */
	private void addCreateFromMethod(EasyClass clazz, JDefinedClass jc) {

		JMethod createFrom = jc.method(JMod.PUBLIC, this._cm.ref(clazz.targetClassName), "createFrom");
		createFrom.param(CSVRecord.class, "record");
		createFrom._throws(java.text.ParseException.class);

		JVar dateFormat = null;

		if (clazz.hasDateField()) {

			dateFormat = createFrom.body().decl(this._cm.ref(SimpleDateFormat.class), "sdf");
			dateFormat.init(JExpr._new(this._cm.ref(SimpleDateFormat.class)).arg("dd/MM/yy"));	

		}

		JClass createFromResultType = this._cm.ref(clazz.targetClassName);
		JVar createFromResult = createFrom.body().decl(createFromResultType, clazz.targetClassName.toLowerCase());
		createFromResult.init(JExpr._new(this._cm.ref(clazz.targetClassName)));

		List<EasyField> fields = new ArrayList<EasyField>(clazz.fields);
		Collections.sort(fields, _FIELD_INDEX_COMP);

		for (EasyField field : fields) {

			JExpression p2 = JExpr.direct("record.get(" + field.index + ")");

			if (field.type.equals(EasyType.TEXT.getType())) {
				createFrom.body().add(createFromResult.invoke("set" + field.targetFieldName).arg(p2));
			} else if (field.type.equals(EasyType.DATE.getType())) {
				createFrom.body().add(
						createFromResult.invoke("set" + field.targetFieldName).arg(
								dateFormat.invoke("parse").arg(p2)
								));
			} else if (field.type.equals(EasyType.INTEGER.getType())) {
				createFrom.body().add(
						createFromResult.invoke("set" + field.targetFieldName).arg(
								this._cm.ref(Integer.class).staticInvoke("valueOf").arg(p2)
								));
			}

		}

		createFrom.body()._return(createFromResult);

	}

	/**
	 * Creates the "add" interface method.
	 * 
	 * @param clazz
	 * @param definedClass
	 * @param repoMap
	 */
	private void addAddMethod(EasyClass clazz, JDefinedClass definedClass) {

		JFieldVar repoMap = definedClass.fields().get(definedClass.name());

		JMethod addMethod = definedClass.method(JMod.PUBLIC, this._cm.BOOLEAN, "add");
		addMethod._throws(IllegalArgumentException.class);
		JVar param = addMethod.param(this._cm.ref(clazz.targetClassName), "item");

		addMethod.body()
		._if(param.eq(JExpr._null()))
		._then()
		._throw(JExpr._new(this._cm.ref(IllegalArgumentException.class)).arg("item cannot be null!"));

		addMethod.body()
		._if(param.invoke("getKeyValue").eq(JExpr._null()).cor(param.invoke("getKeyValue").invoke("isEmpty")))
		._then()
		._throw(JExpr._new(this._cm.ref(IllegalArgumentException.class)).arg("item key value cannot be null or empty!"));

		addMethod.body()
		._if(repoMap.invoke("containsKey").arg(param.invoke("getKeyValue")).not())
		._then()
		.add(repoMap.invoke("put").arg(param.invoke("getKeyValue")).arg(param))
		._return(JExpr.TRUE);

		addMethod.body()._return(JExpr.FALSE);

	}

	private void addGetByIdMethod(EasyClass clazz, JDefinedClass jc, JFieldVar map) {

		JMethod getById = jc.method(JMod.PUBLIC, this._cm.ref(clazz.targetClassName), "getById");
		JVar param = getById.param(String.class, "id");
		getById.body()._return(JExpr._this().ref(map).invoke("get").arg(param));

	}

	private void addGetInputFileNameMethod(EasyClass clazz, JDefinedClass jc) {

		JMethod getInputFileName = jc.method(JMod.PUBLIC, String.class, "getInputFileName");
		getInputFileName.body()._return(JExpr.lit(clazz.fileName));

	}

	private void addSizeMethod(EasyClass clazz, JDefinedClass definedClass) {

		JFieldVar repoMap = definedClass.fields().get(definedClass.name());
		JMethod size = definedClass.method(JMod.PUBLIC, this._cm.INT, "size");
		size.body()._return(repoMap.invoke("size"));

	}

	/**
	 * Generates the Repositories class.
	 */
	private void addRepositoriesClass() throws JClassAlreadyExistsException {

		JDefinedClass repos = this._cm._package(_MODEL_PACKAGE_NAME)._class(_REPOSITORIES_CLASS);
		repos.javadoc().add("This class has been generated by the EasyData library.\n");
		repos.javadoc().add("DO NOT MODIFY this class manually.");

		JType jtype = this._cm.ref(java.util.Map.class).narrow(
				this._cm.ref(Class.class).narrow(this._cm.wildcard()),
				this._cm.ref(EasyRepository.class).narrow(this._cm.wildcard())
				);

		JClass jtypeImpl = this._cm.ref(java.util.HashMap.class).narrow(
				this._cm.ref(Class.class).narrow(this._cm.wildcard()),
				this._cm.ref(EasyRepository.class).narrow(this._cm.wildcard())
				);

		JFieldVar jField = repos.field(JMod.PRIVATE | JMod.STATIC, jtype, "REPOS");
		jField.init(JExpr._new(jtypeImpl));

		// get method
		JType genericType = this._cm.directClass("T");
		JMethod get = repos.method(JMod.PUBLIC | JMod.STATIC, genericType, "get");

		JClass genericClass = this._cm.ref(EasyRepository.class).narrow(this._cm.wildcard());

		get.generify("T", genericClass);
		JClass parameterType = this._cm.ref(Class.class).narrow(genericType);
		JVar getParam = get.param(parameterType, "type");
		get.body()._return(getParam.invoke("cast").arg(JExpr.ref("REPOS").invoke("get").arg(getParam)));

	}

	/**
	 * Adds the generated Repositories class 'init' method.
	 * 
	 * It puts an instance of every Repository class in the map and
	 * calls 'init' on every Repository in the map.
	 */
	private void addRepositoriesInitMethod() {

		JDefinedClass repos = this._cm._package(_MODEL_PACKAGE_NAME)._getClass(_REPOSITORIES_CLASS);

		// init method
		JMethod init = repos.method(JMod.PUBLIC | JMod.STATIC, this._cm.VOID, "init");
		JVar param = init.param(String.class, "path");
		init._throws(IOException.class);

		for (EasyClass clazz : this._em.classes) {

			String name = getPlural(clazz.targetClassName);
			init.body().add(JExpr.ref("REPOS").invoke("put")
					.arg(JExpr.dotclass(this._cm.ref(name)))
					.arg(JExpr._new(this._cm.ref(name))));

		}

		JClass repo = this._cm.ref(Iterator.class).narrow(this._cm.ref(EasyRepository.class).narrow(this._cm.wildcard()));;
		init.body().decl(repo, "iter", JExpr.ref("REPOS").invoke("values").invoke("iterator"));

		JWhileLoop loop = init.body()._while(JExpr.ref("iter").invoke("hasNext"));
		JVar repoVar = loop.body().decl(this._cm.ref(EasyRepository.class).narrow(this._cm.wildcard()), "repo", JExpr.ref("iter").invoke("next"));
		loop.body().add(repoVar.invoke("init").arg(param));

	}

	/**
	 * Get the already generated Repository class for an EasyClass definition
	 * in the specified package.
	 * 
	 * @param pkg
	 * @param clazz
	 * @return the already generated Repository class, null if the class has not be generated yet
	 */
	private JDefinedClass getRepository(JPackage pkg, EasyClass clazz) {
		String name = getPlural(clazz.targetClassName);
		return pkg._getClass(name);
	}

	private String getPlural(String singular) {
		return singular + getPluralSuffix(singular);
	}

	/**
	 * Determine the plural suffix for the given String.
	 * 
	 * @param singular
	 * @return 's' if the singular does not end on 's', 'es' otherwise
	 */
	private String getPluralSuffix(String singular) {
		String suffix = "s";
		if (singular.endsWith("s")) {
			suffix = "es";
		}
		return suffix;
	}

}
